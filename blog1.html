<!DOCTYPE HTML>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Engineering Log: Molecular Swarm Control | Shahmir Aziz</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheet.css">
    <style>
        .blog-post {
            max-width: 700px;
            margin: 40px auto;
            padding: 20px;
            line-height: 1.8;
        }
        .blog-title {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 10px;
            color: #1a1a1a;
        }
        .blog-date {
            color: #666;
            font-size: 14px;
            margin-bottom: 30px;
        }
        .blog-content {
            font-size: 15px;
            color: #3a3a3a;
        }
        .blog-content h3 {
            font-size: 20px;
            margin: 30px 0 15px 0;
            color: #1a1a1a;
        }
        pre {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 13px;
            line-height: 1.5;
            border-left: 3px solid #0d7a3e;
        }
        .equation {
            text-align: center;
            margin: 20px 0;
            font-style: italic;
        }
        .back-link {
            margin-bottom: 30px;
        }
        .log-entry {
            background: #f9f9f9;
            padding: 15px;
            margin: 20px 0;
            border-left: 3px solid #666;
        }
        .log-date {
            font-weight: 600;
            color: #0d7a3e;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div class="blog-post">
        <div class="back-link">
            <a href="index.html">← Back to main</a>
        </div>

        <h1 class="blog-title">Engineering Log: Stochastic Gradient Descent for Molecular Swarm Control</h1>
        <div class="blog-date">Project Week 14 - December 2024</div>

        <div class="blog-content">
            <p>
                <strong>Status:</strong> 85% complete. Core algorithm converging, hardware integration pending.<br>
                <strong>Blocking issue:</strong> Gradient explosion at t>1000 timesteps in viscous media.
            </p>

            <h3>Problem Statement</h3>
            <p>
                Extension of my microrobotics work at Harvard - now controlling swarms instead of single robots.
                Can't use classical control theory for coordinating 10^4 magnetic nanoparticles in blood flow.
                PID controllers fail catastrophically above N=100 particles due to nonlinear inter-particle forces.
                Need real-time control at 10Hz for surgical applications.
            </p>

            <div class="log-entry">
                <span class="log-date">Week 1-4:</span><br>
                Failed with model predictive control. Computational complexity O(N^3) makes it useless for swarms.
                Pivoted to learning-based approach.
            </div>

            <h3>Current Approach: Policy Gradients + MD</h3>
            <p>
                Key insight: treat swarm control as a reinforcement learning problem. State = particle positions/velocities,
                Action = magnetic field configuration, Reward = formation accuracy - energy cost.
            </p>

            <p>
                The dynamics follow overdamped Langevin (Reynolds number ~ 10^-6):
            </p>

            <div class="equation">
                γ dr<sub>i</sub>/dt = F<sub>mag</sub> + F<sub>particle-particle</sub> + F<sub>thermal</sub>
            </div>

            <div class="log-entry">
                <span class="log-date">Week 5-8:</span><br>
                Built custom CUDA kernels for particle force calculations. Initial Python implementation: 0.002 Hz.
                After optimization: 847 Hz for 10^4 particles. Good enough.
            </div>

            <h3>What's Working</h3>

            <p><strong>1. Graph Neural Network state encoding</strong></p>
            <p>
                Particles naturally form a k-NN graph. Using 3-layer message passing to capture local interactions.
                This cut state dimension from O(N^2) to O(N), making gradients tractable.
            </p>

<pre>
# Simplified architecture (actual implementation in CUDA/C++)
def encode_swarm_state(positions, velocities):
    # Build adjacency based on distance
    edges = knn_graph(positions, k=12)  # Each particle sees 12 neighbors

    # Node features: position, velocity, local density
    features = torch.cat([positions, velocities, compute_density(positions)], -1)

    # Message passing
    for layer in self.gnn_layers:
        features = layer(features, edges)

    return global_mean_pool(features)  # Permutation invariant
</pre>

            <p><strong>2. Natural policy gradients</strong></p>
            <p>
                Vanilla REINFORCE was sample-inefficient (needed 10^6 episodes to converge).
                Natural gradients with Fisher information metric improved this to ~10^3 episodes:
            </p>

<pre>
# Fisher information approximation
F = E[∇log_π * ∇log_π.T]  # Expectation over trajectories

# Natural gradient update
θ_new = θ + α * F^(-1) @ ∇J(θ)
</pre>

            <div class="log-entry">
                <span class="log-date">Week 9-11:</span><br>
                Major breakthrough: discovered that pretraining on simplified 2D simulations transfers to 3D.
                This cut training time from 72 hours to 8 hours. Still too slow for iteration but manageable.
            </div>

            <h3>Current Bottlenecks</h3>

            <p><strong>1. Gradient explosion (UNSOLVED)</strong></p>
            <p>
                At long time horizons (t>1000 steps), gradients blow up. Tried gradient clipping, smaller learning rates,
                different optimizers. Nothing fully works. Current hypothesis: chaos in particle dynamics makes
                long-term credit assignment impossible. May need hierarchical policies.
            </p>

            <p><strong>2. Sim-to-real gap</strong></p>
            <p>
                Policies trained in simulation show 87% success rate. In microfluidic test chamber: 61%.
                Main issues:
            </p>
            <ul>
                <li>Particle size distribution (assumed monodisperse, reality: ±15% variation)</li>
                <li>Unknown flow perturbations from chamber walls</li>
                <li>Magnetic field calibration drift (~2% per hour)</li>
            </ul>

            <div class="log-entry">
                <span class="log-date">Week 12-14 (current):</span><br>
                Building domain randomization into training. Adding noise to particle properties, random flow fields,
                magnetic field perturbations. Early results: 71% real-world success rate. Getting there.
            </div>

            <h3>Experimental Setup</h3>
            <p>
                Testing with Fe₃O₄ nanoparticles (50nm diameter) in glycerol solution.
                8-coil electromagnetic array for 3D field control (adapted from Harvard MicroRobotics setup).
                OptiTrack motion capture for ground truth positions. Similar viscosity to what we saw
                in the SOMA gastric tissue penetration studies.
            </p>

            <p>
                Discovered that particle aggregation is a major issue above 10^15 particles/mL.
                Added citrate coating which helps but changes magnetic response. Need to retrain policies.
            </p>

            <h3>Next Steps</h3>

            <ul>
                <li><strong>Week 15:</strong> Implement hierarchical policy (high-level planner → low-level controller)</li>
                <li><strong>Week 16:</strong> Test in blood analog fluid (45% glycerol, 55% water + albumin)</li>
                <li><strong>Week 17:</strong> Animal trials preparation (waiting on IACUC approval)</li>
                <li><strong>Week 18:</strong> Integrate with lipid vesicle delivery system for targeted therapy</li>
            </ul>

            <h3>Open Questions</h3>

            <p>
                1. Is RL the right approach? Considering hybrid: RL for high-level planning, optimal control for execution.<br>
                2. How to handle particle loss (absorption, aggregation)? Current policy assumes fixed N.<br>
                3. Can we prove any stability guarantees? Probably not, but reviewers will ask.
            </p>

            <div class="log-entry">
                <span class="log-date">Note to self:</span><br>
                Remember to test with heterogeneous particle mixtures before publication.
                Previous work assumed homogeneous particles and got destroyed in peer review.
            </div>

            <h3>Resources</h3>
            <p>
                Code: Still cleaning up for release. Too messy for public consumption.<br>
                Preprint: Targeting February submission after animal trials.<br>
                Data: 2.3TB of trajectories available on request (need to sign NDA due to unpublished work).
            </p>

            <p style="margin-top: 40px; font-style: italic;">
                This work is supported by NIH R01 and uses 400 GPU-hours/week on the Oxford cluster.
                If you're working on similar problems, reach out - happy to share what hasn't worked.
            </p>
        </div>
    </div>
</body>
</html>